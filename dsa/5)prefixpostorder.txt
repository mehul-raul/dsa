#include <iostream>
#include <stack>

using namespace std;

// Structure to represent a node in the expression tree
struct TreeNode {
    char data;
    TreeNode* left;
    TreeNode* right;

    TreeNode(char val) : data(val), left(nullptr), right(nullptr) {}
};

// Function to check if a character is an operand
bool isOperand(char c) {
    return (c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z');
}

// Function to construct an expression tree from a prefix expression
TreeNode* constructExpressionTree(string prefix) {
    stack<TreeNode*> st;

    // Traverse the prefix expression from right to left
    for (int i = prefix.size() - 1; i >= 0; i--) {
        char c = prefix[i];

        // Create a new node for each character in the expression
        TreeNode* newNode = new TreeNode(c);

        // If the character is an operand, push it onto the stack
        if (isOperand(c)) {
            st.push(newNode);
        } else {
            // If the character is an operator, pop two operands from the stack
            // and set them as the children of the new node
            TreeNode* op1 = st.top();
            st.pop();
            TreeNode* op2 = st.top();
            st.pop();
            newNode->left = op1;
            newNode->right = op2;
            // Push the new node back onto the stack
            st.push(newNode);
        }
    }

    // The root of the expression tree is the only node remaining on the stack
    return st.top();
}

// Function to traverse the expression tree using postorder traversal non-recursively
void postorderTraversal(TreeNode* root) {
    if (root == nullptr) return;

    stack<TreeNode*> st;
    TreeNode* curr = root;
    TreeNode* lastVisited = nullptr;

    while (curr || !st.empty()) {
        if (curr) {
            st.push(curr);
            curr = curr->left;
        } else {
            TreeNode* peekNode = st.top();
            // If the right child exists and is not processed yet,
            // move to it. Otherwise, visit the node.
            if (peekNode->right && lastVisited != peekNode->right) {
                curr = peekNode->right;
            } else {
                cout << peekNode->data << " ";
                lastVisited = peekNode;
                st.pop();
            }
        }
    }
}

// Function to delete the entire tree
void deleteTree(TreeNode* root) {
    if (root == nullptr) return;
    deleteTree(root->left);
    deleteTree(root->right);
    delete root;
}

int main() {
    string prefix;
    cout << "Enter the prefix expression: ";
    cin >> prefix;

    TreeNode* root = constructExpressionTree(prefix);

    // Traverse the expression tree using postorder traversal
    cout << "Postorder traversal of the expression tree: ";
    postorderTraversal(root);
    cout << endl;

    // Delete the entire tree to free up memory
    deleteTree(root);

    return 0;
}
