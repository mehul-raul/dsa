#include<bits/stdc++.h> // Include necessary libraries
using namespace std;
#define MAX 100 // Define maximum number of vertices in the graph

struct Graph // Structure to represent a graph
{
    int data[MAX][MAX]; // Adjacency matrix to store edge weights
    int vertices; // Number of vertices in the graph
    int edges; // Number of edges in the graph

    void read() // Method to read graph data from user
    {
        cout << "Enter the number of vertices in the graph-\n";
        cin >> vertices; // Input number of vertices

        for (int i = 0; i < vertices; i++) // Loop to read edge weights
        {
            for (int j = 0; j < vertices; j++)
            {
                if (i != j)
                {
                    cout << "Enter the weight between vertex " + to_string(i) + " and " + to_string(j) + "\n";
                    cin >> data[i][j]; // Input edge weight
                }
                else
                {
                    data[i][j] = 0; // Diagonal elements are set to 0
                }
            }
        }
    }

    void display() // Method to display the adjacency matrix
    {
        for (int i = 0; i < vertices; i++) // Loop through rows
        {
            for (int j = 0; j < vertices; j++) // Loop through columns
            {
                cout << data[i][j] << " "; // Display edge weights
            }
            cout << endl; // Move to next row
        }
    }

    int minKey(int key[], bool mstSet[]) // Method to find the vertex with minimum key value
    {
        int min = INT_MAX, min_index;
        for (int v = 0; v < vertices; v++) // Loop through vertices
        {
            if (mstSet[v] == false && key[v] < min)
            {
                min = key[v], min_index = v; // Update minimum key and index
            }
        }
        return min_index; // Return index of minimum key vertex
    }

    void printMST(int parent[]) // Method to print the Minimum Spanning Tree (MST)
    {
        int cost = 0; // Initialize total cost of MST
        cout<<"Edge \tWeight\n"; // Print header for MST
        for (int i = 1; i < vertices; i++) // Loop through vertices
        {
            cout<< parent[i] <<" - "<<i<<" \t"<< data[i][parent[i]] <<" \n"; // Print MST edges and their weights
        }
        for (int i = 1; i < vertices; i++) // Loop through vertices
        {
            cost += data[i][parent[i]]; // Calculate total cost of MST
        }
        cout << cost << endl; // Print total cost of MST
    }

    void primMST() // Method to find MST using Prim's algorithm
    {
        int parent[vertices]; // Array to store MST
        int key[vertices]; // Array to store key values used to pick minimum weight edge
        bool mstSet[vertices]; // Array to track vertices included in MST
 
        for (int i = 0; i < vertices; i++) // Initialize arrays
        {
            key[i] = INT_MAX, mstSet[i] = false; // Set key values to maximum and MST set to false
        }
        key[0] = 0; // Set key value of first vertex to 0
        parent[0] = -1; // First node is root of MST
 
        for (int count = 0; count < vertices - 1; count++) // Loop to construct MST
        {
            int u = minKey(key, mstSet); // Pick the minimum key vertex from the set of vertices not yet included in MST
            mstSet[u] = true; // Include the picked vertex in MST
 
            for (int v = 0; v < vertices; v++) // Update key value and parent index of the adjacent vertices of the picked vertex
            {
                if (data[u][v] && mstSet[v] == false && data[u][v] < key[v]) // Update key value only if weight of data[u][v] is smaller than key[v]
                {
                    parent[v] = u, key[v] = data[u][v]; // Set parent index and key value of vertex v
                }
            }
        }
        printMST(parent); // Print the constructed MST
    }
};

int main() // Main function
{
    Graph g; // Create graph object
    g.read(); // Read graph data
    g.display(); // Display adjacency matrix
    g.primMST(); // Find and print Minimum Spanning Tree (MST) using Prim's algorithm
    return 0; // Return statement for main function
}
